import { RJSFSchema } from "@rjsf/utils";
import { Column } from "../column";

const supportedOperations : string[] = [
  "var",
  "if",
  "==",
  "===",
  "!=",
  "!==",
  "!",
  "!!",
  "or",
  "and",
  ">",
  ">=",
  "<",
  "<=",
  "max",
  "min",
  "+",
  "-",
  "*",
  "/",
  "%",
  "map",
  "reduce",
  "filter",
  "all",
  "none",
  "some",
  "merge",
  "in",
  "cat",
  "substr",
  "zip",
  "Math.abs",
  "Math.ceil",
  "Math.exp",
  "Math.floor",
  "Math.hypot",
  "Math.log",
  "Math.log10",
  "Math.log2",
  "Math.pow",
  "Math.random",
  "Math.round",
  "Math.sign",
  "Math.sqrt",
  "Math.trunc",
  "Turf.along",
  "Turf.area",
  "Turf.bbox",
  "Turf.bboxPolygon",
  "Turf.bearing",
  "Turf.center",
  "Turf.centerOfMass",
  "Turf.centroid",
  "Turf.destination",
  "Turf.distance",
  "Turf.envelope",
  "Turf.length",
  "Turf.midpoint",
  "Turf.pointOnFeature",
  "Turf.polygonTangents",
  "Turf.pointToLineDistance",
  "Turf.rhumbBearing",
  "Turf.rhumbDestination",
  "Turf.rhumbDistance",
  "Turf.square",
  "Turf.greatCircle",
  "Turf.cleanCoords",
  "Turf.flip",
  "Turf.rewind",
  "Turf.round",
  "Turf.truncate",
  "Turf.bboxClip",
  "Turf.bezierSpline",
  "Turf.buffer",
  "Turf.circle",
  "Turf.clone",
  "Turf.concave",
  "Turf.convex",
  "Turf.difference",
  "Turf.dissolve",
  "Turf.intersect",
  "Turf.lineOffset",
  "Turf.polygonSmooth",
  "Turf.simplify",
  "Turf.tesselate",
  "Turf.transformRotate",
  "Turf.transformTranslate",
  "Turf.transformScale",
  "Turf.union",
  "Turf.voronoi",
  "Turf.combine",
  "Turf.explode",
  "Turf.flatten",
  "Turf.lineToPolygon",
  "Turf.polygonize",
  "Turf.polygonToLine",
  "Turf.ellipse",
  "Turf.kinks",
  "Turf.lineArc",
  "Turf.lineChunk",
  "Turf.lineIntersect",
  "Turf.lineOverlap",
  "Turf.lineSegment",
  "Turf.lineSlice",
  "Turf.lineSliceAlong",
  "Turf.lineSplit",
  "Turf.mask",
  "Turf.nearestPointOnLine",
  "Turf.sector",
  "Turf.shortestPath",
  "Turf.unkinkPolygon",
  "Turf.featureCollection",
  "Turf.feature",
  "Turf.geometryCollection",
  "Turf.lineString",
  "Turf.multiLineString",
  "Turf.multiPoint",
  "Turf.multiPolygon",
  "Turf.point",
  "Turf.polygon",
  "Turf.randomPosition",
  "Turf.randomPoint",
  "Turf.randomLineString",
  "Turf.randomPolygon",
  "Turf.sample",
  "Turf.interpolate",
  "Turf.isobands",
  "Turf.isolines",
  "Turf.planepoint",
  "Turf.tin",
  "Turf.pointsWithinPolygon",
  "Turf.tag",
  "Turf.hexGrid",
  "Turf.pointGrid",
  "Turf.squareGrid",
  "Turf.triangleGrid",
  "Turf.nearestPoint",
  "Turf.collect",
  "Turf.clustersDbscan",
  "Turf.clustersKmeans",
  "Turf.coordAll",
  "Turf.coordEach",
  "Turf.coordReduce",
  "Turf.featureEach",
  "Turf.featureReduce",
  "Turf.flattenEach",
  "Turf.flattenReduce",
  "Turf.getCoord",
  "Turf.getCoords",
  "Turf.getGeom",
  "Turf.getType",
  "Turf.geomEach",
  "Turf.geomReduce",
  "Turf.propEach",
  "Turf.propReduce",
  "Turf.segmentEach",
  "Turf.segmentReduce",
  "Turf.getCluster",
  "Turf.clusterEach",
  "Turf.clusterReduce",
  "Turf.collectionOf",
  "Turf.containsNumber",
  "Turf.geojsonType",
  "Turf.featureOf",
  "Turf.booleanClockwise",
  "Turf.booleanConcave",
  "Turf.booleanContains",
  "Turf.booleanCrosses",
  "Turf.booleanDisjoint",
  "Turf.booleanEqual",
  "Turf.booleanIntersects",
  "Turf.booleanOverlap",
  "Turf.booleanParallel",
  "Turf.booleanPointInPolygon",
  "Turf.booleanPointOnLine",
  "Turf.booleanWithin",
  "Turf.bearingToAzimuth",
  "Turf.convertArea",
  "Turf.convertLength",
  "Turf.degreesToRadians",
  "Turf.lengthToRadians",
  "Turf.lengthToDegrees",
  "Turf.radiansToLength",
  "Turf.radiansToDegrees",
  "Turf.toMercator",
  "Turf.toWgs84",
  "Geo.beginning",
  "Geo.ending",
  "Geo.novelty",
  "Geo.unionMany",
];

export const getSchema = (columns: Column[]) => {
  const schema : RJSFSchema = {
    $ref: "#/$defs/expression",
    $defs: {
      expression: {
        type: "object",
        anyOf: [
          { $ref: "#/$defs/stringLiteral" },
          { $ref: "#/$defs/numberLiteral" },
          { $ref: "#/$defs/booleanLiteral" },
          { $ref: "#/$defs/dateTimeLiteral" },
          { $ref: "#/$defs/pointLiteral" },
          { $ref: "#/$defs/featureReference" },
          { $ref: "#/$defs/property" },
          { $ref: "#/$defs/operation" },
        ],
        default: { var: "feature" },
      },
      stringLiteral: {type: "string", title: "String Literal"},
      numberLiteral: {type: "number", title: "Number Literal"},
      booleanLiteral: {type: "boolean", title: "Boolean Literal"},
      dateTimeLiteral: {type: "string", format: "date-time", title: "DateTime Literal"},
      pointLiteral: {
        type: "array",
        items: {type: "number", default: 0},
        title: "Point Literal",
        default: [-122.33419, 47.60005],
      },
      featureReference: {
        type: "object",
        title: "Feature Reference",
        properties: {index: { type: "number", title: "Index" }},
      },
      property: {type: "object", title: "Property", properties: {var: { $ref: "#/$defs/propertyNames" }}},
      propertyNames: {
        enum: [
          "index",
          "feature",
          ...columns.map(col => `feature.properties.${col.name}`)
        ],
        default: "feature"
      },
      operation: {
        type: "object",
        title: "Operation",
        properties: {
          operator: {type: "string", enum: supportedOperations,},
          arguments: {
            type: "array",
            items: { "$ref": "#/$defs/expression" },
          },
        },
      },
    }
  };
  return schema;
};